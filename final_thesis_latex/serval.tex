\newpage
\section{The Serval Networking Architecture}
\subsection{Introduction}
Serval\footnote{More information about the Serval Architecture can be found in the presentation in the Appendix (\ref{sec:servaldhtpres}).} is an end-host stack evolving into a service-centric network architecture, proposed and prototyped by the \href{https://sns.cs.princeton.edu/}{systems and networking group} at \href{https://www.princeton.edu}{Princeton University}, in 2012.



\paragraph{} In the original paper "A Service Access Layer, at Your Service" (2011)\cite{Freedman2011} and later on "Serval: An End-Host Stack for Service-Centric Networking" (2012)\cite{Nordstrom2012}, Freedman, Nordstr{\"o}m et. al. first decompose the needs of modern networked applications, locate the discordances with the current Network Stack, study previous work and how each of them individually fails to stand as a proper solution, rethink the current TCP/IP Networking Stack and propose two simple abstractions that can obliterate the legacy problems discussed on Problem Definition (section \ref{problemdefinition}).

Furthermore they investigate how those abstractions fit in a new 3.5 layer, the Service Access Layer (SAL)\nomenclature{SAL}{Service Access Layer}, and emphasize on the clean service-level data/control plane separation it imposes.
Additionally, they review a formally-verified end-to-end connection control protocol (ECCP) \nomenclature{ECCP}{End-to-End Connection Control Protocol}, which completes the Serval architecture as the end-host signalling channel. 
In the end, they focus on the SAL prototype and the lessons learned from building it.



\input{abstractions.tex}


\newpage
\subsection{Service-Level Routing}
\begin{figure}
\centering
\phantomsection
\includegraphics[scale=0.3]{figures/service_level_routing}
\caption[Service-Level Routing]{Service-level Routing based on serviceIDs}
\label{fig:ser_resol}
\end{figure}


No need for deep packet inspection in load balancers



\subsubsection{Late binding}



\include{serviceresolution.tex}



\newpage
\subsection{Serval Network Stack}
Unlike other next-generation networking proposals, Serval is neither running in the user space, nor is using a translator.
Nevertheless, it does not replace the existing network stack.
Serval is implemented in a kernel module which places itself within an unmodified stack, coexisting with it.
This way developers may choose to use either PF\_INET or PF\_SERVAL, or even both of them in a single application.

In this section we are concentrating on SAL, the Service Access Layer, which offers functionality any
networked service application could use.


\subsubsection{Service Access Layer}

\begin{figure}
\centering
\phantomsection
\includegraphics[scale=0.3]{figures/sal_position}
\caption[Service Access Layer position]{Service Access Layer position in the OSI model}
\label{fig:sal_position}
\end{figure}

The Service Access Layer (SAL) is the keystone of the Serval architecture.
Shipped as serval.ko kernel module, SAL bridges the gap between the application layer and the network layer, and undertakes the operations of Serval active sockets, service resolution, end-to-end signalling, service registration and so on.
In fact, all the "magic" behind Serval is implemented in this module, which can be virtually positioned between the Network and the Transport layers in the OSI model (figure \ref{fig:sal_position}).

hide ip etc


Extra points go to Serval for being transport-protocol agnostic.
This means that developers may choose to use either TCP, UDP\nomenclature{UDP}{User Datagram Protocol}, ATP\nomenclature{ATP}{AppleTalk Transaction Protocol}, FCP\nomenclature{FCP}{Fibre Channel Protocol} or actually any transport protocol, since it is supported by SAL, without modifying the source code of their application.
This opens new windows for experimentation and innovation.



\subsubsection{Serval Packets Structure}
Serval packets are constructed in SAL, using from bottom to top the network layer IP header, Serval header and extensions, and a transport protocol's headers.

Physical, datalink and network layer headers are the common ones one would expect to find.
This is because SAL is not involved in exchanging packets in any level.
Therefore until a packet reaches SAL (service table and flow table), it is processed by middleware as a normal TCP/IP packet in order to reach its final destination.
This feature makes Serval compatible with existing hardware and could assist in its incremental deployment.

In the Service Access Layer level, an extra SAL header is added of minimum 12 bytes.
The structure, is presented in table~\ref{table:salheader}.
\begin{enumerate} \itemsep1pt \parskip0pt 
\parsep0pt
  \item First 4 bytes represent the source flowID of the packet.
  \item The next 4 bytes represent the destination flowID of the packet.
  This is used for demultiplexing with a local socket.
  \item The next byte, marked as SAL Header Length, gives the total SAL header length, including extensions, in 4byte words.
  For a packet that carries payload and no extensions the value is 3.
  \item The 10th byte indicates the protocol of the transport layer which is used; 6 for TCP and 17 for UDP.
  \item The last 2 bytes of the header are used as checksum.
\end{enumerate}

\begin{table}
\begin{center}
  \begin{tabularx}{\linewidth}{|c|X|X|X|X|}
  	\hline
  	Octet &	0 & 1 & 2 & 3 \\ \hline
  	0 & \multicolumn{4}{c|}{Source FlowID}\\ \hline
  	4 & \multicolumn{4}{c|}{Destination FlowID}\\ \hline
  	8 &	Header Length & {Transfer\linebreak Protocol} &	\multicolumn{2}{|c|}{Checksum}	\\
	\hline
  \end{tabularx}
  \caption[Serval packet header structure]{Serval packet header structure}
  \label{table:salheader}
\end{center}
\end{table}

During the initialization of a connection, destination flowID is zero (0).
The next packet though returns both the flowID in the server side and the serviceID once again, to identify which service the response comes from; quite useful for the case of concurrent service resolution requests.

\newpage
When the SAL header length is greater than 3, then there are extensions in the header.
There are 5 types of extensions:
\begin{enumerate} \itemsep1pt \parskip0pt 
\parsep0pt
  \item SAL\_PAD\_EXT
  \item SAL\_CONTROL\_EXT
  \item SAL\_SERVICE\_EXT
  \item SAL\_ADDRESS\_EXT
  \item SAL\_SOURCE\_EXT
\end{enumerate}
In total the extensions included in a packet can not exceed 10.
\\ The SAL\_PAD\_EXT is a special kind of header, of just 1 byte, which helps align the extensions to 8-byte blocks.
\\[0.2cm]
\noindent For easier debugging of Serval packets, we created a LUA Wireshark dissector.
Source code and instructions are attached in the Appendix \ref{sec:wirlua}.



\newpage
\subsection{Service Controller}
elevates services to first-class citizens in the management of the network control plane.



\input{ports.tex}
\input{profiling_serval.tex}